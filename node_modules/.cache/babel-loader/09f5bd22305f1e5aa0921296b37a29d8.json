{"ast":null,"code":"const _ = require('lodash');\n\nconst {\n  columnToLetter\n} = require('./utils');\n\nconst {\n  GoogleSpreadsheetFormulaError\n} = require('./errors');\n\nclass GoogleSpreadsheetCell {\n  constructor(parentSheet, rowIndex, columnIndex, cellData) {\n    this._sheet = parentSheet; // the parent GoogleSpreadsheetWorksheet instance\n\n    this._row = rowIndex;\n    this._column = columnIndex;\n\n    this._updateRawData(cellData);\n\n    return this;\n  } // newData can be undefined/null if the cell is totally empty and unformatted\n\n\n  _updateRawData(newData = {}) {\n    this._rawData = newData;\n    this._draftData = {}; // stuff to save\n\n    this._error = null;\n\n    if (_.get(this._rawData, 'effectiveValue.errorValue')) {\n      this._error = new GoogleSpreadsheetFormulaError(this._rawData.effectiveValue.errorValue);\n    }\n  } // CELL LOCATION/ADDRESS /////////////////////////////////////////////////////////////////////////\n\n\n  get rowIndex() {\n    return this._row;\n  }\n\n  get columnIndex() {\n    return this._column;\n  }\n\n  get a1Column() {\n    return columnToLetter(this._column + 1);\n  }\n\n  get a1Row() {\n    return this._row + 1;\n  } // a1 row numbers start at 1 instead of 0\n\n\n  get a1Address() {\n    return `${this.a1Column}${this.a1Row}`;\n  } // CELL CONTENTS - VALUE/FORMULA/NOTES ///////////////////////////////////////////////////////////\n\n\n  get value() {\n    // const typeKey = _.keys(this._rawData.effectiveValue)[0];\n    if (this._draftData.value !== undefined) throw new Error('Value has been changed');\n    if (this._error) return this._error;\n    if (!this._rawData.effectiveValue) return null;\n    return _.values(this._rawData.effectiveValue)[0];\n  }\n\n  set value(newValue) {\n    if (_.isBoolean(newValue)) {\n      this._draftData.valueType = 'boolValue';\n    } else if (_.isString(newValue)) {\n      if (newValue.substr(0, 1) === '=') this._draftData.valueType = 'formulaValue';else this._draftData.valueType = 'stringValue';\n    } else if (_.isFinite(newValue)) {\n      this._draftData.valueType = 'numberValue';\n    } else if (_.isNil(newValue)) {\n      // null or undefined\n      this._draftData.valueType = 'stringValue';\n      newValue = '';\n    } else {\n      throw new Error('Set value to boolean, string, or number');\n    }\n\n    this._draftData.value = newValue;\n  }\n\n  get valueType() {\n    // an error only happens with a formula\n    if (this._error) return 'errorValue';\n    if (!this._rawData.effectiveValue) return null;\n    return _.keys(this._rawData.effectiveValue)[0];\n  }\n\n  get formattedValue() {\n    return this._rawData.formattedValue || null;\n  }\n\n  set formattedValue(newVal) {\n    throw new Error('You cannot modify the formatted value directly');\n  }\n\n  get formula() {\n    return _.get(this._rawData, 'userEnteredValue.formulaValue', null);\n  }\n\n  set formula(newValue) {\n    if (newValue.substr(0, 1) !== '=') throw new Error('formula must begin with \"=\"');\n    this.value = newValue; // use existing value setter\n  }\n\n  get formulaError() {\n    return this._error;\n  }\n\n  get hyperlink() {\n    if (this._draftData.value) throw new Error('Save cell to be able to read hyperlink');\n    return this._rawData.hyperlink;\n  }\n\n  set hyperlink(val) {\n    throw new Error('Do not set hyperlink directly. Instead set cell.formula, for example `cell.formula = \\'=HYPERLINK(\"http://google.com\", \"Google\")\\'`');\n  }\n\n  get note() {\n    return this._draftData.note !== undefined ? this._draftData.note : this._rawData.note;\n  }\n\n  set note(newVal) {\n    if (newVal === null || newVal === undefined) newVal = '';\n    if (!_.isString(newVal)) throw new Error('Note must be a string');\n    if (newVal === this._rawData.note) delete this._draftData.note;else this._draftData.note = newVal;\n  } // CELL FORMATTING ///////////////////////////////////////////////////////////////////////////////\n\n\n  get userEnteredFormat() {\n    return this._rawData.userEnteredFormat;\n  }\n\n  get effectiveFormat() {\n    return this._rawData.effectiveFormat;\n  }\n\n  set userEnteredFormat(newVal) {\n    throw new Error('Do not modify directly, instead use format properties');\n  }\n\n  set effectiveFormat(newVal) {\n    throw new Error('Read-only');\n  }\n\n  _getFormatParam(param) {\n    // we freeze the object so users don't change nested props accidentally\n    // TODO: figure out something that would throw an error if you try to update it?\n    if (_.get(this._draftData, `userEnteredFormat.${param}`)) {\n      throw new Error('User format is unsaved - save the cell to be able to read it again');\n    }\n\n    return Object.freeze(this._rawData.userEnteredFormat[param]);\n  }\n\n  _setFormatParam(param, newVal) {\n    if (_.isEqual(newVal, _.get(this._rawData, `userEnteredFormat.${param}`))) {\n      _.unset(this._draftData, `userEnteredFormat.${param}`);\n    } else {\n      _.set(this._draftData, `userEnteredFormat.${param}`, newVal);\n\n      this._draftData.clearFormat = false;\n    }\n  } // format getters\n\n\n  get numberFormat() {\n    return this._getFormatParam('numberFormat');\n  }\n\n  get backgroundColor() {\n    return this._getFormatParam('backgroundColor');\n  }\n\n  get borders() {\n    return this._getFormatParam('borders');\n  }\n\n  get padding() {\n    return this._getFormatParam('padding');\n  }\n\n  get horizontalAlignment() {\n    return this._getFormatParam('horizontalAlignment');\n  }\n\n  get verticalAlignment() {\n    return this._getFormatParam('verticalAlignment');\n  }\n\n  get wrapStrategy() {\n    return this._getFormatParam('wrapStrategy');\n  }\n\n  get textDirection() {\n    return this._getFormatParam('textDirection');\n  }\n\n  get textFormat() {\n    return this._getFormatParam('textFormat');\n  }\n\n  get hyperlinkDisplayType() {\n    return this._getFormatParam('hyperlinkDisplayType');\n  }\n\n  get textRotation() {\n    return this._getFormatParam('textRotation');\n  } // format setters\n\n\n  set numberFormat(newVal) {\n    return this._setFormatParam('numberFormat', newVal);\n  }\n\n  set backgroundColor(newVal) {\n    return this._setFormatParam('backgroundColor', newVal);\n  }\n\n  set borders(newVal) {\n    return this._setFormatParam('borders', newVal);\n  }\n\n  set padding(newVal) {\n    return this._setFormatParam('padding', newVal);\n  }\n\n  set horizontalAlignment(newVal) {\n    return this._setFormatParam('horizontalAlignment', newVal);\n  }\n\n  set verticalAlignment(newVal) {\n    return this._setFormatParam('verticalAlignment', newVal);\n  }\n\n  set wrapStrategy(newVal) {\n    return this._setFormatParam('wrapStrategy', newVal);\n  }\n\n  set textDirection(newVal) {\n    return this._setFormatParam('textDirection', newVal);\n  }\n\n  set textFormat(newVal) {\n    return this._setFormatParam('textFormat', newVal);\n  }\n\n  set hyperlinkDisplayType(newVal) {\n    return this._setFormatParam('hyperlinkDisplayType', newVal);\n  }\n\n  set textRotation(newVal) {\n    return this._setFormatParam('textRotation', newVal);\n  }\n\n  clearAllFormatting() {\n    // need to track this separately since by setting/unsetting things, we may end up with\n    // this._draftData.userEnteredFormat as an empty object, but not an intent to clear it\n    this._draftData.clearFormat = true;\n    delete this._draftData.userEnteredFormat;\n  } // SAVING + UTILS ////////////////////////////////////////////////////////////////////////////////\n  // returns true if there are any updates that have not been saved yet\n\n\n  get _isDirty() {\n    // have to be careful about checking undefined rather than falsy\n    // in case a new value is empty string or 0 or false\n    if (this._draftData.note !== undefined) return true;\n    if (_.keys(this._draftData.userEnteredFormat).length) return true;\n    if (this._draftData.clearFormat) return true;\n    if (this._draftData.value !== undefined) return true;\n    return false;\n  }\n\n  discardUnsavedChanges() {\n    this._draftData = {};\n  }\n\n  async save() {\n    await this._sheet.saveUpdatedCells([this]);\n  } // used by worksheet when saving cells\n  // returns an individual batchUpdate request to update the cell\n\n\n  _getUpdateRequest() {\n    // this logic should match the _isDirty logic above\n    // but we need it broken up to build the request below\n    const isValueUpdated = this._draftData.value !== undefined;\n    const isNoteUpdated = this._draftData.note !== undefined;\n    const isFormatUpdated = !!_.keys(this._draftData.userEnteredFormat || {}).length;\n    const isFormatCleared = this._draftData.clearFormat; // if no updates, we return null, which we can filter out later before sending requests\n\n    if (!_.some([isValueUpdated, isNoteUpdated, isFormatUpdated, isFormatCleared])) {\n      return null;\n    } // build up the formatting object, which has some quirks...\n\n\n    const format = { // have to pass the whole object or it will clear existing properties\n      ...this._rawData.userEnteredFormat,\n      ...this._draftData.userEnteredFormat\n    }; // if background color already set, cell has backgroundColor and backgroundColorStyle\n    // but backgroundColorStyle takes precendence so we must remove to set the color\n    // see https://developers.google.com/sheets/api/reference/rest/v4/spreadsheets/cells#CellFormat\n\n    if (_.get(this._draftData, 'userEnteredFormat.backgroundColor')) {\n      delete format.backgroundColorStyle;\n    }\n\n    return {\n      updateCells: {\n        rows: [{\n          values: [{ ...(isValueUpdated && {\n              userEnteredValue: {\n                [this._draftData.valueType]: this._draftData.value\n              }\n            }),\n            ...(isNoteUpdated && {\n              note: this._draftData.note\n            }),\n            ...(isFormatUpdated && {\n              userEnteredFormat: format\n            }),\n            ...(isFormatCleared && {\n              userEnteredFormat: {}\n            })\n          }]\n        }],\n        // turns into a string of which fields to update ex \"note,userEnteredFormat\"\n        fields: _.keys(_.pickBy({\n          userEnteredValue: isValueUpdated,\n          note: isNoteUpdated,\n          userEnteredFormat: isFormatUpdated || isFormatCleared\n        })).join(','),\n        start: {\n          sheetId: this._sheet.sheetId,\n          rowIndex: this.rowIndex,\n          columnIndex: this.columnIndex\n        }\n      }\n    };\n  }\n\n}\n\nmodule.exports = GoogleSpreadsheetCell;","map":{"version":3,"sources":["/home/ethan/Documents/DevHub/SalaryDataExplorer/frontend/node_modules/google-spreadsheet/lib/GoogleSpreadsheetCell.js"],"names":["_","require","columnToLetter","GoogleSpreadsheetFormulaError","GoogleSpreadsheetCell","constructor","parentSheet","rowIndex","columnIndex","cellData","_sheet","_row","_column","_updateRawData","newData","_rawData","_draftData","_error","get","effectiveValue","errorValue","a1Column","a1Row","a1Address","value","undefined","Error","values","newValue","isBoolean","valueType","isString","substr","isFinite","isNil","keys","formattedValue","newVal","formula","formulaError","hyperlink","val","note","userEnteredFormat","effectiveFormat","_getFormatParam","param","Object","freeze","_setFormatParam","isEqual","unset","set","clearFormat","numberFormat","backgroundColor","borders","padding","horizontalAlignment","verticalAlignment","wrapStrategy","textDirection","textFormat","hyperlinkDisplayType","textRotation","clearAllFormatting","_isDirty","length","discardUnsavedChanges","save","saveUpdatedCells","_getUpdateRequest","isValueUpdated","isNoteUpdated","isFormatUpdated","isFormatCleared","some","format","backgroundColorStyle","updateCells","rows","userEnteredValue","fields","pickBy","join","start","sheetId","module","exports"],"mappings":"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","sourcesContent":["const _ = require('lodash');\n\nconst { columnToLetter } = require('./utils');\n\nconst { GoogleSpreadsheetFormulaError } = require('./errors');\n\nclass GoogleSpreadsheetCell {\n  constructor(parentSheet, rowIndex, columnIndex, cellData) {\n    this._sheet = parentSheet; // the parent GoogleSpreadsheetWorksheet instance\n    this._row = rowIndex;\n    this._column = columnIndex;\n\n    this._updateRawData(cellData);\n    return this;\n  }\n\n  // newData can be undefined/null if the cell is totally empty and unformatted\n  _updateRawData(newData = {}) {\n    this._rawData = newData;\n    this._draftData = {}; // stuff to save\n    this._error = null;\n    if (_.get(this._rawData, 'effectiveValue.errorValue')) {\n      this._error = new GoogleSpreadsheetFormulaError(this._rawData.effectiveValue.errorValue);\n    }\n  }\n\n  // CELL LOCATION/ADDRESS /////////////////////////////////////////////////////////////////////////\n  get rowIndex() { return this._row; }\n  get columnIndex() { return this._column; }\n  get a1Column() { return columnToLetter(this._column + 1); }\n  get a1Row() { return this._row + 1; } // a1 row numbers start at 1 instead of 0\n  get a1Address() { return `${this.a1Column}${this.a1Row}`; }\n\n  // CELL CONTENTS - VALUE/FORMULA/NOTES ///////////////////////////////////////////////////////////\n  get value() {\n    // const typeKey = _.keys(this._rawData.effectiveValue)[0];\n    if (this._draftData.value !== undefined) throw new Error('Value has been changed');\n    if (this._error) return this._error;\n    if (!this._rawData.effectiveValue) return null;\n    return _.values(this._rawData.effectiveValue)[0];\n  }\n\n  set value(newValue) {\n    if (_.isBoolean(newValue)) {\n      this._draftData.valueType = 'boolValue';\n    } else if (_.isString(newValue)) {\n      if (newValue.substr(0, 1) === '=') this._draftData.valueType = 'formulaValue';\n      else this._draftData.valueType = 'stringValue';\n    } else if (_.isFinite(newValue)) {\n      this._draftData.valueType = 'numberValue';\n    } else if (_.isNil(newValue)) {\n      // null or undefined\n      this._draftData.valueType = 'stringValue';\n      newValue = '';\n    } else {\n      throw new Error('Set value to boolean, string, or number');\n    }\n    this._draftData.value = newValue;\n  }\n\n  get valueType() {\n    // an error only happens with a formula\n    if (this._error) return 'errorValue';\n    if (!this._rawData.effectiveValue) return null;\n    return _.keys(this._rawData.effectiveValue)[0];\n  }\n\n  get formattedValue() { return this._rawData.formattedValue || null; }\n  set formattedValue(newVal) {\n    throw new Error('You cannot modify the formatted value directly');\n  }\n\n  get formula() { return _.get(this._rawData, 'userEnteredValue.formulaValue', null); }\n  set formula(newValue) {\n    if (newValue.substr(0, 1) !== '=') throw new Error('formula must begin with \"=\"');\n    this.value = newValue; // use existing value setter\n  }\n  get formulaError() { return this._error; }\n\n  get hyperlink() {\n    if (this._draftData.value) throw new Error('Save cell to be able to read hyperlink');\n    return this._rawData.hyperlink;\n  }\n  set hyperlink(val) {\n    throw new Error('Do not set hyperlink directly. Instead set cell.formula, for example `cell.formula = \\'=HYPERLINK(\"http://google.com\", \"Google\")\\'`');\n  }\n\n  get note() {\n    return this._draftData.note !== undefined ? this._draftData.note : this._rawData.note;\n  }\n\n  set note(newVal) {\n    if (newVal === null || newVal === undefined) newVal = '';\n    if (!_.isString(newVal)) throw new Error('Note must be a string');\n    if (newVal === this._rawData.note) delete this._draftData.note;\n    else this._draftData.note = newVal;\n  }\n\n  // CELL FORMATTING ///////////////////////////////////////////////////////////////////////////////\n  get userEnteredFormat() { return this._rawData.userEnteredFormat; }\n  get effectiveFormat() { return this._rawData.effectiveFormat; }\n  set userEnteredFormat(newVal) { throw new Error('Do not modify directly, instead use format properties'); }\n  set effectiveFormat(newVal) { throw new Error('Read-only'); }\n\n  _getFormatParam(param) {\n    // we freeze the object so users don't change nested props accidentally\n    // TODO: figure out something that would throw an error if you try to update it?\n    if (_.get(this._draftData, `userEnteredFormat.${param}`)) {\n      throw new Error('User format is unsaved - save the cell to be able to read it again');\n    }\n    return Object.freeze(this._rawData.userEnteredFormat[param]);\n  }\n\n  _setFormatParam(param, newVal) {\n    if (_.isEqual(newVal, _.get(this._rawData, `userEnteredFormat.${param}`))) {\n      _.unset(this._draftData, `userEnteredFormat.${param}`);\n    } else {\n      _.set(this._draftData, `userEnteredFormat.${param}`, newVal);\n      this._draftData.clearFormat = false;\n    }\n  }\n\n  // format getters\n  get numberFormat() { return this._getFormatParam('numberFormat'); }\n  get backgroundColor() { return this._getFormatParam('backgroundColor'); }\n  get borders() { return this._getFormatParam('borders'); }\n  get padding() { return this._getFormatParam('padding'); }\n  get horizontalAlignment() { return this._getFormatParam('horizontalAlignment'); }\n  get verticalAlignment() { return this._getFormatParam('verticalAlignment'); }\n  get wrapStrategy() { return this._getFormatParam('wrapStrategy'); }\n  get textDirection() { return this._getFormatParam('textDirection'); }\n  get textFormat() { return this._getFormatParam('textFormat'); }\n  get hyperlinkDisplayType() { return this._getFormatParam('hyperlinkDisplayType'); }\n  get textRotation() { return this._getFormatParam('textRotation'); }\n\n  // format setters\n  set numberFormat(newVal) { return this._setFormatParam('numberFormat', newVal); }\n  set backgroundColor(newVal) { return this._setFormatParam('backgroundColor', newVal); }\n  set borders(newVal) { return this._setFormatParam('borders', newVal); }\n  set padding(newVal) { return this._setFormatParam('padding', newVal); }\n  set horizontalAlignment(newVal) { return this._setFormatParam('horizontalAlignment', newVal); }\n  set verticalAlignment(newVal) { return this._setFormatParam('verticalAlignment', newVal); }\n  set wrapStrategy(newVal) { return this._setFormatParam('wrapStrategy', newVal); }\n  set textDirection(newVal) { return this._setFormatParam('textDirection', newVal); }\n  set textFormat(newVal) { return this._setFormatParam('textFormat', newVal); }\n  set hyperlinkDisplayType(newVal) { return this._setFormatParam('hyperlinkDisplayType', newVal); }\n  set textRotation(newVal) { return this._setFormatParam('textRotation', newVal); }\n\n  clearAllFormatting() {\n    // need to track this separately since by setting/unsetting things, we may end up with\n    // this._draftData.userEnteredFormat as an empty object, but not an intent to clear it\n    this._draftData.clearFormat = true;\n    delete this._draftData.userEnteredFormat;\n  }\n\n  // SAVING + UTILS ////////////////////////////////////////////////////////////////////////////////\n\n  // returns true if there are any updates that have not been saved yet\n  get _isDirty() {\n    // have to be careful about checking undefined rather than falsy\n    // in case a new value is empty string or 0 or false\n    if (this._draftData.note !== undefined) return true;\n    if (_.keys(this._draftData.userEnteredFormat).length) return true;\n    if (this._draftData.clearFormat) return true;\n    if (this._draftData.value !== undefined) return true;\n    return false;\n  }\n\n  discardUnsavedChanges() {\n    this._draftData = {};\n  }\n\n  async save() {\n    await this._sheet.saveUpdatedCells([this]);\n  }\n\n  // used by worksheet when saving cells\n  // returns an individual batchUpdate request to update the cell\n  _getUpdateRequest() {\n    // this logic should match the _isDirty logic above\n    // but we need it broken up to build the request below\n    const isValueUpdated = this._draftData.value !== undefined;\n    const isNoteUpdated = this._draftData.note !== undefined;\n    const isFormatUpdated = !!_.keys(this._draftData.userEnteredFormat || {}).length;\n    const isFormatCleared = this._draftData.clearFormat;\n\n    // if no updates, we return null, which we can filter out later before sending requests\n    if (!_.some([isValueUpdated, isNoteUpdated, isFormatUpdated, isFormatCleared])) {\n      return null;\n    }\n\n    // build up the formatting object, which has some quirks...\n    const format = {\n      // have to pass the whole object or it will clear existing properties\n      ...this._rawData.userEnteredFormat,\n      ...this._draftData.userEnteredFormat,\n    };\n    // if background color already set, cell has backgroundColor and backgroundColorStyle\n    // but backgroundColorStyle takes precendence so we must remove to set the color\n    // see https://developers.google.com/sheets/api/reference/rest/v4/spreadsheets/cells#CellFormat\n    if (_.get(this._draftData, 'userEnteredFormat.backgroundColor')) {\n      delete (format.backgroundColorStyle);\n    }\n\n\n    return {\n      updateCells: {\n        rows: [{\n          values: [{\n            ...isValueUpdated && {\n              userEnteredValue: { [this._draftData.valueType]: this._draftData.value },\n            },\n            ...isNoteUpdated && {\n              note: this._draftData.note,\n            },\n            ...isFormatUpdated && {\n              userEnteredFormat: format,\n            },\n            ...isFormatCleared && {\n              userEnteredFormat: {},\n            },\n          }],\n        }],\n        // turns into a string of which fields to update ex \"note,userEnteredFormat\"\n        fields: _.keys(_.pickBy({\n          userEnteredValue: isValueUpdated,\n          note: isNoteUpdated,\n          userEnteredFormat: isFormatUpdated || isFormatCleared,\n        })).join(','),\n        start: {\n          sheetId: this._sheet.sheetId,\n          rowIndex: this.rowIndex,\n          columnIndex: this.columnIndex,\n        },\n      },\n    };\n  }\n}\n\nmodule.exports = GoogleSpreadsheetCell;\n"]},"metadata":{},"sourceType":"script"}